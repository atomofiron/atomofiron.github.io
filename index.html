<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title></title>

<style type="text/css">
@font-face {
	font-family: fixedsys;
	src: url("./new/fixedsys.ttf");
}
html, body, video {
	padding: 0px;
	margin: 0px;
	background-color: #000000;
	font-family: arial;
	overflow-x: hidden;
	font-family: fixedsys;

	user-select: none;
	-moz-user-select: none;
	-webkit-user-select: none;
	-webkit-touch-callout: none;
    -ms-user-select: none;
}
img {
	-webkit-user-drag: none;
}
::-webkit-scrollbar {
    display: none;
}
* {
	box-sizing: content-box;
}
video {
    filter: brightness(0.8) contrast(2) hue-rotate(300deg);
}
canvas {
	width: 100%;
    image-rendering: optimizeSpeed;             /* Older versions of FF          */
    image-rendering: -moz-crisp-edges;          /* FF 6.0+                       */
    image-rendering: -webkit-optimize-contrast; /* Safari                        */
    image-rendering: -o-crisp-edges;            /* OS X & Windows Opera (12.02+) */
    image-rendering: pixelated;                 /* Awesome future-browsers       */
    -ms-interpolation-mode: nearest-neighbor;
}
.underlayer_box {
	top: 0;
	margin: auto;
}
.layer_box {
	top: 0;
	margin: auto;
	mix-blend-mode: exclusion;
}
.layer {
	width: 440px;
	height: 411px;
	/*mix-blend-mode: exclusion; doesn't work in Safari for nested element*/
}
#content {
	display: none;
}
#volume_box {
	width: 40px;
	height: 128px;
	border: 2px #550055 solid;
	box-shadow: 0 0 0 1px #ff00ff;
	border-radius: 0px;
	margin: 16px;
	overflow: hidden;
	background-color: #550055;
	z-index: 1;
	cursor: ns-resize;
	position: absolute;
	right: 0;
	filter: opacity(0.5);
    transition: all 0.2s ease-in-out;
}
#volume_box:hover {
	filter: opacity(1);
}
#volume_track_line {
	width: 4px;
	height: 92px;
	background-color: #ff00ff;
	border-radius: 0px;
	position: absolute;
	left: 0;
	right: 0;
	top: 0;
	bottom: 0;
	margin: auto;
	opacity: 0.0; /* эхх */
}
#volume_track {
	width: 100%;
	/*height: 80px; in html attribute*/
	position: absolute;
	background-color: #ff00ff;
	margin: 0 auto;
	bottom: 0;
	left: 0;
	right: 0;
	border-radius: 0px;
}
#volume_track img {
	width: 24px;
	height: 24px;
	position: absolute;
	left: 0;
	top: 8px;
	right: 0;
	margin: auto;
}
#header {
	height: 450px;
	position: relative;
	text-align: center;
}
.center_box {
	display: flex;
	justify-content: center;
	position: absolute;
	bottom: 0;
	left: 0;
	right: 0;
}
#sky {
	width: 100%;
	height: 100%;
	left: 0;
	top: 0;
	right: 0;
	bottom: 0;
	margin: auto;
}
#firmament {
	width: 100%;
	height: 100%;
	left: 0;
	top: 0;
	right: 0;
	bottom: 0;
	margin: auto;
	position: absolute;
	mix-blend-mode: exclusion;
	background: radial-gradient(farthest-corner at 50% 100%, rgba(0, 80, 128, 0.5), rgba(0, 80, 128, 0.5) 30%, rgba(0, 0, 0, 0.5)), url("./new/noise.svg");
	filter: contrast(2) brightness(50%);
	opacity: 0.5;
}
#canvas_ground {
	background: radial-gradient(circle at 50% 0%, rgba(255, 0, 255, 0.05), rgba(255, 0, 255, 0.025));
    margin-bottom: -4px;
}
@keyframes blink {
    0% {
           color: rgba(255, 255, 255, 1);
    }
    50% {
           color: rgba(255, 255, 255, 0);
    }
    100% {
           color: rgba(255, 255, 255, 1);
    }
}
@-webkit-keyframes blink {
    0% {
           color: rgba(255, 255, 255, 1);
    }
    50% {
           color: rgba(255, 255, 255, 0);
    }
    100% {
           color: rgba(255, 255, 255, 1);
    }
}

.blinking {
    -moz-transition: all 1s ease-in-out;
    -webkit-transition: all 1s ease-in-out;
    -o-transition: all 1s ease-in-out;
    -ms-transition: all 1s ease-in-out;
    transition: all 1s ease-in-out;
    -moz-animation: blink normal 1s infinite ease-in-out; /* Firefox */
    -webkit-animation: blink normal 1s infinite ease-in-out; /* Webkit */
    -ms-animation: blink normal 1s infinite ease-in-out; /* IE */
    animation: blink normal 1s infinite ease-in-out; /* Opera */
}

#progress_box {
	width: 256px;
	border: 1px #ff00ff solid;
	margin-left: auto;
	margin-right: auto;
	padding: 0px 16px 16px 16px;
}
#progress_title {
	color: white;
	font-size: 32px;
	background-color: black;
	position: relative;
	top: -20px;
	left: -8px;
	padding: 0px 8px;
}
#progress_bar tr td {
	width: 40px;
	height: 20px;
	background-color: black;
	border-top: 2px black solid;
	border-bottom: 2px black solid;
}
#start_button {
	cursor: pointer;
	visibility: hidden;
	border: 1px #ff00ff solid;
	right: 0;
	margin-left: auto;
}
#start_button_text {
	background-color: #ff00ff;
	font-size: 24px;
	padding: 8px 16px 8px 16px;
}
#start_button_text:hover {
	background-color: black;
	color: #ff00ff;
}
</style>
</head>
<body>

<div id="volume_box">
	<div id="volume_track_line"></div>
	<div id="volume_track" style="height: 80px">
		<img id="volume_icon" src="./new/volume-off.png" />
	</div>
</div>
<div id="content">
	<div id="header">
		<div class="center_box">
			<div>
				<video id="zero2" style="display: none;" width="800" autoplay="" loop="" playsmuted="" muted="" [muted]="'muted'">
				    <source src="./new/02-5.mp4" type="video/mp4">
				</video>
			</div>
		</div>

		<div id="firmament" class="center_box"></div>
		<div id="sky" class="center_box">
			<canvas id="canvas_sky"></canvas>
		</div>

		<div class="center_box underlayer_box">
			<img id="avaBlack" class="layer" src="./new/red.png" style="filter: brightness(0);" />
		</div>
		<div class="center_box layer_box">
			<img id="avaRed" class="layer" src="./new/red.png" />
		</div>
		<div class="center_box layer_box">
			<img id="avaGreen" class="layer" src="./new/green.png" />
		</div>
		<div class="center_box layer_box">
			<img id="avaBlue" class="layer" src="./new/blue.png" />
		</div>

		<div class="center_box">
			<img src="./new/mnts.png" width="1000" height="206" />
		</div>

		<div id="title" style="position: absolute; color: white; padding: 16px; text-align: left;">
			<span id="name" style="font-size: 24px;"></span>
			<br>
			<span id="vocation" style="font-size: 16px; line-height: 24px;"></span>&ZeroWidthSpace;<span id="cursor" class="blinking" style="display: none; font-weight: bold;">_</span>
		</div>
	</div>

	<!-- <audio src="cut.mp3" controls></audio> -->

	<canvas id="canvas_ground" style="width: 100%;"></canvas>
</div>

<div id="progress_box_overlay" style="display: table; position: absolute; top: 0; left: 0; height: 100%; width: 100%;">
<div style="display: table-cell; vertical-align: middle;">
	<div id="progress_box">
		<span id="progress_title">Loading…</span>
		<br>
		<table id="progress_bar" cellspacing="0" cellpadding="0" style="border: 1px #ff00ff solid; padding-right: 2px;">
			<tr id="progress_row"></tr>
		</table>
		<br>
		<table id="start_button">
			<tr>
				<td id="start_button_text">Continue</td>
			</tr>
		</table>
	</div>
</div>
</div>

<script type="text/javascript">

const poop = console.log
function get(id) {
	return document.getElementById(id)
}

const px = 'px'
function noPx(value) {
	let str = value.endsWith(px) ? value.substring(0, value.length - 2) : value
	return (str.length == 0) ? 0 : parseInt(str)
}

const imgs = document.getElementsByTagName("img")
for (let img of imgs) {
  img.draggable = false
}

const groundCanvas = document.getElementById("canvas_ground")
const ground = groundCanvas.getContext("2d");

const skyCanvas = document.getElementById("canvas_sky")
const sky = skyCanvas.getContext("2d");

const pixelRatio = window.devicePixelRatio
const lineWidthMin = 0.5 * pixelRatio
const lineWidthMax = 5 * pixelRatio
const hLineWidthMax = lineWidthMax * 2
const hLineCount = 25
let vLineCount = 30

const zeroTwo = get("zero2")
const tanLimit = Math.PI / 2
let time = 0

function updateLinesCount() {
	vLineCount = window.innerWidth * pixelRatio / 100
	vLineCount = vLineCount | 0
	vLineCount += vLineCount % 2
}
document.onresize = updateLinesCount
window.onresize = updateLinesCount
updateLinesCount()

function drowVerticalLines(frameWidth, frameHeight) {
	ground.lineCap = 'round'
	ground.strokeStyle = "#ff00ff"

	const vOffset = 0
	const hStep = frameWidth / vLineCount
	const centerX = frameWidth / 2
	for (let x = hStep / 2; x < frameWidth - hStep / 4; x += hStep) {
		ground.lineWidth = lineWidthMax * (1 - Math.abs(centerX - x) / centerX)
		ground.beginPath()
		ground.moveTo(x, 0)
		let dif = centerX - x
		dif *= Math.abs(dif) / hStep + 5
		ground.lineTo(x - dif, frameHeight)
		ground.stroke()
	}
}
function drowHorizontalLines() {
	const groundWidth = groundCanvas.width
	const groundHeight = groundCanvas.height

	ground.lineWidth = lineWidthMax
    ground.beginPath()
	ground.moveTo(0, 0)
	ground.lineTo(groundWidth, 0)
	ground.stroke()

	const yOffset = 50
	for (let i = 0; i < hLineCount * 2; i++) {
		let arg = time
		arg += (i + 1) * tanLimit / hLineCount / 2
		arg %= tanLimit
		let y = Math.tan(arg) * 50 - yOffset
		if (y < 0 || y > groundHeight) continue
		y = y|0 + 0.5
		const lineWidth = hLineWidthMax * (y / groundHeight)
		ground.lineWidth = Math.max(lineWidthMin, lineWidth)
	    ground.beginPath()
		ground.moveTo(0, y)
		ground.lineTo(groundWidth, y)
		ground.stroke()
	}
}
function drawWorld() {
	const windowWidth = window.innerWidth * pixelRatio
	const windowHeight = window.innerHeight * pixelRatio

	groundCanvas.width = windowWidth
	groundCanvas.height = windowHeight
	const skyHeight = skyCanvas.clientHeight * pixelRatio
	skyCanvas.width = windowWidth
	skyCanvas.height = skyHeight

	drowVerticalLines(windowWidth, windowHeight)
	drowHorizontalLines()
	drawStars()
	time += Math.PI / 3000
	time %= tanLimit
}

const stars = [ ]
const starCount = 300

for (let i = 0; i < starCount; i++) {
	stars.push(null)
	let j = stars.length * Math.random()
	j |= 0
	stars[i] = stars[j]
	stars[j] = [ i, Math.sqrt(Math.random()) ]
}
function drawStars() {
	const skyWidth = skyCanvas.width
	const skyHeight = skyCanvas.height
	if (skyHeight <= 0) return
	sky.lineWidth = lineWidthMin
	sky.strokeStyle = "#ffffff"

	let dx = 0
	for (let i = 0; i < stars.length; i++) {
		dx += skyWidth / stars.length
		const star = stars[i]
		let arg = time
		arg += star[0] * tanLimit / starCount
		arg %= tanLimit
		let y = Math.tan(arg ) * 50
		let y2 = Math.tan(arg - 0.02 - 0.02 * star[1]) * 50 - 1
		if (y2 > skyHeight) continue
		const lineWidth = lineWidthMax * (y / skyHeight)
		sky.lineWidth = Math.max(lineWidthMin, lineWidth)
		y += skyHeight * star[1]
		y2 += skyHeight * star[1]
		if (y2 > skyHeight) continue
		drawStar(dx, y, y2, skyWidth, skyHeight)
	}
}
function drawStar(dx, y, y2, skyWidth, skyHeight) {
	let x = dx + skyWidth / stars.length
	let x2 = x
	x += (x - skyWidth / 2) * (y / skyHeight)
	x2 += (x2 - skyWidth / 2) * (y2 / skyHeight)

    sky.beginPath()
	sky.moveTo(x, skyHeight - y)
	sky.lineTo(x2, skyHeight - y2)
	sky.stroke()
}


setInterval(drawWorld, 20)


const avaBlack = get("avaBlack")
const avaRed = get("avaRed")
const avaGreen = get("avaGreen")
const avaBlue = get("avaBlue")
const trembling = 5
let disappearance = 1 // 10
let maxTranslation = 20
let intensitySecuence = 0
let intensityStep = Math.PI / 30

let deviationRed = 0
let deviationGreen = 0
let deviationBlue = 0
let desortingInterval = 0
let oneWay = false
let disortingStarterInterval = 0
let probability = 0.5

function startDisorting(anyWay) {
	if (anyWay != true) {
		const yes = Math.random() < probability
		if (yes) probability /= 2
		else {
			probability += Math.min(0.3, (1 - probability) / 2)
			return
		}
	}
	clearInterval(desortingInterval)
	intensitySecuence = 0
	const deviation = Math.PI * 2 * Math.random()
	if (oneWay) {
		deviationRed = 0
		deviationGreen = 0
		deviationBlue = Math.PI
	} else {
		deviationRed = deviation
		deviationGreen = deviationRed + Math.PI * 2 / 3
		deviationBlue = deviationRed + Math.PI * 4 / 3
	}
	desortingInterval = setInterval(distortPicture, 16)
}
function distortPicture() {
	const r = oneWay ? Math.min(Math.PI / 2, intensitySecuence) : intensitySecuence
	intensitySecuence += intensityStep
	if (intensitySecuence > Math.PI) {
		intensitySecuence = 0
		clearInterval(desortingInterval)
		avaRed.style.transform = ''
		avaGreen.style.transform = ''
		avaBlue.style.transform = ''
		if (oneWay) {
			zeroTwoElsePicture(true)
		}
		return
	}
	const intensity = Math.sin(r)
	distortLayer(avaRed, deviationRed, intensity, oneWay)
	distortLayer(avaGreen, deviationGreen, intensity)
	distortLayer(avaBlue, deviationBlue, intensity)
}
function distortLayer(element, radian, intensity, onlyTrembling) {
	const dx = intensity * disappearance * (Math.random() > 0.5) ? trembling : -trembling
	const dy = intensity * disappearance * (Math.random() > 0.5) ? trembling : -trembling
	const x = onlyTrembling ? dx : (Math.cos(radian) * maxTranslation * disappearance) * intensity + dx
	const y = onlyTrembling ? dy : (Math.sin(radian) * maxTranslation * disappearance) * intensity + dy
	element.style.transform = `translate(${x}px, ${y}px)`
}

function zeroTwoElsePicture(showZeroTwo) {
	const picture = showZeroTwo ? 'none' : 'block'
	avaBlack.style.display = picture
	avaRed.style.display = picture
	avaGreen.style.display = picture
	avaBlue.style.display = picture
	zeroTwo.style.display = showZeroTwo ? 'block' : 'none'
}

function hidePicture() {
	clearInterval(disortingStarterInterval)
	oneWay = true
	disappearance = 10
	intensitySecuence = 0
	startDisorting(true)
	avaBlack.style.display = 'none'
}
function showPicture() {
	oneWay = false
	disappearance = 1
	zeroTwoElsePicture(false)
	clearInterval(disortingStarterInterval)
	disortingStarterInterval = setInterval(startDisorting, 900)
	startDisorting(true)
}


const volumeBox = get("volume_box")
const volumeTrack = get("volume_track")
const volumeIcon = get("volume_icon")
const startVolume = function(ev) {
	allowClicks = true
	volumeBox.onmousemove = moveVolume
}
const stopVolume = function() {
	volumeBox.onmousemove = null
}
volumeBox.onmousedown = startVolume
volumeBox.onmouseleave = stopVolume
volumeBox.onmouseup = stopVolume
volumeBox.onpointerdown = startVolume
volumeBox.onpointereave = stopVolume
volumeBox.onpointerup = stopVolume
let allowClicks = true
const moveVolume = function(event) {
	allowClicks = false
	let height = noPx(volumeTrack.style.height) - event.movementY
	updadeVolumeOffset(height)
}
function updadeVolumeOffset(height) {
	const min = 40
	height = Math.max(min, height)
	height = Math.min(volumeBox.clientHeight, height)
	volumeTrack.style.height = height + px

	let volume = (height - min) / (volumeBox.clientHeight - min)
	audio.volume = Math.pow(volume, 2)
}
volumeBox.onclick = function(event) {
	if (!allowClicks) return
	const height = volumeBox.clientHeight - event.clientY + 40
	updadeVolumeOffset(height)
}

function onVolumeChanged(event) {
	updateVolumeIcon(Math.sqrt(audio.volume))
}

function updateVolumeIcon(volume) {
	if (volume == 0) volumeIcon.src = './new/volume-off.png'
	else if (volume < 1) volumeIcon.src = './new/volume-low.png'
	else volumeIcon.src = './new/volume-high.png'
}



const name = "Yaroslav Nesterov"
const vocation = "Android Developer"
const enjoyer = "Anime Enjoyer"
const cursor = "_"

const titleDiv = get("title")
const nameSpan = get("name")
const vocationSpan = get("vocation")
const cursorSpan = get("cursor")

let titleInterval = 0
nameSpan.innerText = cursor

function showName() {
	const visibleName = nameSpan.innerText
	const index = visibleName.length - 1
	const value = visibleName.substring(0, index)
	if (visibleName.length < name.length + 1) {
		nameSpan.innerText = value + name[index] + cursor
	} else {
		nameSpan.innerText = value
		vocationSpan.innerText = cursor
		clearInterval(titleInterval)
		setInterval(showVocation, 100)
	}
}
function showBlinkingCursor(show) {
	const display = show ? 'inline-block' : 'none'
	if (cursorSpan.style.display != display)
		cursorSpan.style.display = display
}
function showVocation() {
	let text = vocationSpan.innerText
	if (text.endsWith(cursor)) {
		text = text.substring(0, text.length - 1)
	}
	const isVocation = vocation.startsWith(text)
	const toAnime = titleDiv.matches(':hover')
	const remove = text.length > 2 && (isVocation == toAnime)
	if (remove) {
		text = text.substring(0, text.length - 1)
		text += cursor
		showBlinkingCursor(false)
	} else {
		const target = toAnime ? enjoyer : vocation
		if (text.length < target.length) {
			text += target[text.length] + cursor
		} else {
			showBlinkingCursor(true)
		}
	}
	if (vocationSpan.innerText != text) {
		vocationSpan.innerText = text
	}
}

const loadingCompleted = "Completed"
const progressBoxOverlay = get('progress_box_overlay')
const progressBox = get('progress_box')
const progressTitle = get('progress_title')
const progressBar = get('progress_bar')
const progressRow = get('progress_row')
const progressCell = "<td></td>"
const progressMax = 6
let progress = 0

for (let i = 0; i < progressMax; i++) {
	progressRow.innerHTML += progressCell
}
function onResourceLoaded() {
	progress++
	setProgress(progress)
	if (progress == progressMax) {
		progressTitle.innerText = loadingCompleted
		startButton.style.visibility = 'visible'
	}
}
function setProgress(count) {
	const cells = progressBar.getElementsByTagName("td")
	for (let i = 0; i < cells.length; i++) {
		const cell = cells[i]
		cell.style.backgroundColor = (i < count) ? "#ff00ff" : "#000000"
		cell.style.borderLeft = (i == 0 || i <= count) ? "2px #000000 solid" : "1px #ff00ff solid"
		cell.style.borderRight = (i == 0 || i <= count) ? "0px #000000 solid" : "1px #000000 solid"
		cell.style.borderTop = (i == 0 || i < count) ? "2px #000000 solid" : "0px"
		cell.style.borderBottom = (i == 0 || i < count) ? "2px #000000 solid" : "0px"
	}
}
setProgress(0)

const startButton = get("start_button")
startButton.onclick = function() {
	progressBoxOverlay.style.display = 'none'
	audio.play()
	get("content").style.display = 'block'
	titleInterval = setInterval(showName, 100)
}

const audio = new Audio()
const mnts = new Image()
const red = new Image()
const green = new Image()
const blue = new Image()
mnts.onload = onResourceLoaded
red.onload = onResourceLoaded
green.onload = onResourceLoaded
blue.onload = onResourceLoaded
audio.oncanplay = onResourceLoaded

function onFontLoaded() {
	onResourceLoaded()
	red.src = "./new/red.png"
	green.src = "./new/green.png"
	blue.src = "./new/blue.png"
	mnts.src = "./new/mnts.png"
	audio.src = "./new/cut.mp3"
}
if (document.fonts.size > 0 && document.fonts.status == 'loaded') {
	onFontLoaded()
} else {
	document.fonts.onloadingdone = function(event) {
		const fixedsys = event.fontfaces.find((it) => it.family == 'fixedsys')
		if (fixedsys) onFontLoaded()
	}
}

audio.volume = 0.5
audio.onvolumechange = onVolumeChanged
updateVolumeIcon(audio.volume)
audio.onended = function() {
	audio.play()
}
audio.onplay = function() {
	showPicture()
	setTimeout(hidePicture, 48000)
	setTimeout(showPicture, 79000)
	setTimeout(hidePicture, 127000)
	setTimeout(showPicture, 143000)
}

</script>

</body>
</html>